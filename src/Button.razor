@using System.Runtime.CompilerServices
@using Microsoft.AspNetCore.Components.Web
@using Soenneker.Extensions.String
@using Soenneker.Quark.Enums.Size
@using Soenneker.Quark.Anchors
@using Soenneker.Quark.Dtos.Colors
@using Soenneker.Quark.Enums.ButtonTypes
@using Soenneker.Quark.Spans

@inherits Soenneker.Quark.Components.Element
@inject NavigationManager Navigation

@if (Type == ButtonType.Link)
{
	<Anchor To="To" Attributes="BuildAttributes()" >
		@ChildContent
	</Anchor>
}
else
{
	<button @attributes="BuildAttributes()" @onclick="HandleClick" >
		@if (Loading)
		{
			<Span Class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" ></Span>
		}
		@if (LoadingTemplate is not null && Loading)
		{
			@LoadingTemplate
		}
		else
		{
			@ChildContent
		}
	</button>
}

@code {

	[Parameter]
	public ButtonType Type { get; set; } = ButtonType.Button;

	[Parameter]
	public bool Disabled { get; set; }

	[Parameter]
	public bool Loading { get; set; }

	[Parameter]
	public RenderFragment? LoadingTemplate { get; set; }

	[Parameter]
	public string? Value { get; set; }

	[Parameter]
	public string? Name { get; set; }

	[Parameter]
	public string? Form { get; set; }

	[Parameter]
	public bool AutoFocus { get; set; }

	[Parameter]
	public string? To { get; set; }

	[Parameter]
	public Size Size { get; set; } = Size.Default;

	[Parameter]
	public Color Color { get; set; }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private string? GetSizeClass() => Size != Size.Default ? $"btn-{Size.Value}" : null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private string GetColorClass() => Color.IsTheme ? $"btn-{Color.Theme!.Value}" : $"btn-{Color.Css}";

	protected override Dictionary<string, object> BuildAttributes()
	{
		// Start from fully-merged base attributes (class/style already consolidated there)
		Dictionary<string, object> attrs = base.BuildAttributes();

		// We handle click explicitly on the element; remove any composed onclick from base
		attrs.Remove("onclick");

		// Determine element kind
		bool isLink = Type == ButtonType.Link || To.HasContent();

		// Figure out disabled state (treat presence of "disabled" attribute as true)
		bool isDisabled = Disabled || Loading || (Attributes is not null && Attributes.ContainsKey("disabled"));

		// Merge/ensure Bootstrap button classes
		attrs.TryGetValue("class", out object? classObj);
		string currentClass = classObj?.ToString() ?? string.Empty;

		currentClass = EnsureClass(currentClass, "btn");

		string colorClass = GetColorClass();
		currentClass = EnsureClass(currentClass, colorClass);

		string? sizeClass = GetSizeClass();
		if (sizeClass is not null)
			currentClass = EnsureClass(currentClass, sizeClass);

		// Apply disabled visuals for anchor-style buttons
		if (isLink && isDisabled)
			currentClass = EnsureClass(currentClass, "disabled");

		if (currentClass.Length > 0)
			attrs["class"] = currentClass;

		// Common ARIA for loading/disabled
		if (Loading)
			attrs["aria-busy"] = "true";

		// Only set type on real <button>
		if (!isLink)
			attrs["type"] = Type.Value;

		// Real disabled vs. aria-disabled
		if (isLink)
		{
			// Anchor can't be truly disabled; use ARIA and remove focus
			if (isDisabled)
			{
				attrs["aria-disabled"] = "true";
				attrs["tabindex"] = "-1";
				// role is already a good idea for link-as-button
				attrs["role"] = "button";
			}
			else
				attrs.TryAdd("role", "button");
		}
		else
		{
			if (isDisabled)
				attrs["disabled"] = true;
		}

		// Standard button/submit metadata
		if (Value.HasContent()) attrs["value"] = Value!;
		if (Name.HasContent()) attrs["name"] = Name!;
		if (Form.HasContent()) attrs["form"] = Form!;
		if (AutoFocus) attrs["autofocus"] = true;

		// If this is acting as a link, we already render <Anchor>; nothing special beyond attrs.
		return attrs;
	}

	protected override async Task HandleClick(MouseEventArgs args)
	{
		// Respect disabled state at runtime, same semantics as in BuildAttributes
		bool isDisabled = Disabled || Loading || (Attributes is not null && Attributes.ContainsKey("disabled"));
		if (isDisabled)
			return;

		// Programmatic navigation if To is set (and not a hash)
		if (To.HasContent() && !To!.StartsWith("#"))
			Navigation.NavigateTo(To!);

		await base.HandleClick(args);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static string EnsureClass(string existing, string toAdd)
	{
		if (toAdd.IsNullOrEmpty())
			return existing;

		if (existing.IsNullOrEmpty())
			return toAdd;

		// Cheap contains check; no allocations
		return existing.Contains(toAdd, StringComparison.Ordinal) ? existing : $"{existing} {toAdd}";
	}

}